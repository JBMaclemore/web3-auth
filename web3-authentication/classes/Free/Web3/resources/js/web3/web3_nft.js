var TokenABIType1=[{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],type:"function"},{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},],TokenABIType2=[{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}],numBalanceOfParams=1,tokenOfOwnerByIndexFunctionExist=!1;function checkABI(e){for(let t=0;t<e.length;t++)"balanceOf"==e[t].name&&(numBalanceOfParams=e[t].inputs.length),"tokenOfOwnerByIndex"==e[t].name&&(tokenOfOwnerByIndexFunctionExist=!0)}async function getBalanceOfToken(e,t,n,a){let o=-1;return((o=await checkBalance(TokenABIType1,e,t,n,a))<0&&(o=await checkBalance(TokenABIType2,e,t,n,a)),o<0)?-1:o}function getWeb3ContractObject(e,t,n){let a=new Web3(window.ethereum),o=new a.eth.Contract(e,t);return"Ethereum"==n?o.setProvider("https://cloudflare-eth.com/"):o.setProvider("https://polygon-rpc.com/"),o}async function getBalanceFromLoopring(e,t,n){let a=0;return await jQuery.post(ajaxurl,{action:"type_of_request",request:"getLoopringBalance",blockchain:"Loopring",contractAddress:t,walletAddress:e,tokenIDs:n,mo_web3_verify_nonce:wp_nonce},function(e){a=e}),a}async function getBalanceFromCronos(e,t){let n=0;return await jQuery.post(ajaxurl,{action:"type_of_request",request:"getCronosBalance",walletAddress:e,contractAddress:t,mo_web3_verify_nonce:wp_nonce},function(e){(e=JSON.parse(e)).hasOwnProperty("result")&&(n=e.result)}),n*=1e-18}async function checkBalance(e,t,n,a,o=null){let r=-1;checkABI(e);let l=getWeb3ContractObject(e,n,a);try{l.defaultAccount=t}catch(s){return console.log(s),r}if("Cronos"==a)return Number(r=await getBalanceFromCronos(t,n));if(1==numBalanceOfParams){if(o){let u="";try{r=(u=await l.methods.ownerOf(o).call()).toLowerCase()==t.toLowerCase()?1:0}catch(c){console.log(c)}}else try{r=await l.methods.balanceOf(t).call()}catch(p){console.log(p)}}else if(o)try{r=await l.methods.balanceOf(t,o).call()}catch(y){console.log(y)}else{try{r=await l.methods.balanceOf(t,o=await l.methods.tokenOfOwnerByIndex(t,0).call()).call()}catch(f){console.log(f)}r=await getBalanceThroughAPICall(n,t,a)}return Number(r)}async function getBalanceThroughAPICall(e,t,n){let a=0;return await jQuery.post(ajaxurl,{action:"type_of_request",request:"getUserHoldNFTData",blockchain:n,wallet_address:t,contractAddresses:e,mo_web3_verify_nonce:wp_nonce},function(e){a=Number(a=JSON.parse(e).total)}),a}async function getBalanceOfMultipleTokens(e,t,n,a=null){let o=0;if(null!=a&&a.length>0){let r=a?.split(",");for(let l=0;l<r.length;l++){let s=await getBalanceOfToken(e,t,n,r[l]);(s<0||"number"!=typeof s)&&(console.log("Do not support this token standard"),s=0),o+=s}}else o=await getBalanceOfToken(e,t,n,null);return o}async function getUserAccountAssetsDetails(e,t,n,a,o=null){let r=null;return await jQuery.post(ajaxurl,{action:"type_of_request",request:"getUserHoldNFTData",blockchain:n,wallet_address:e,contractAddresses:t,isMultipleToken:!0,pageKey:o,mo_web3_verify_nonce:wp_nonce},function(e){r=JSON.parse(e)}),r}async function mapAssetDataAndConfigAndGetBalance(e,t,n,a){let o=0,r={};for(let l=0;l<n?.length;l++){let s=n[l];"number"==typeof s&&(s=s.toString());r[t.toLowerCase()+"+"+s]=!0}if("ethereum"==a.toLowerCase()||"polygon"==a.toLowerCase()){let u=e?.ownedNfts;for(let c=0;c<u?.length;c++){let p=u[c].contract.address,y=Number(u[c].id.tokenId),f=Number(u[c].balance);y=y.toString();let d=p.toLowerCase()+"+"+y;void 0!=r[d]&&r[d]&&(o+=f)}}else if("algorand"==a.toLowerCase()){let m=e?.assets;for(let g=0;g<m?.length;g++){let w=m[g]["asset-id"],$=Number(m[g].amount);"Number"==typeof w&&(w=w.toString());let h=t+"+"+w;void 0!=r[h]&&r[h]&&(o+=$)}}else if("solana"==a.toLowerCase()){let T=e;for(let k=0;k<T?.length;k++){let B=t+"+"+T[k].mint;void 0!=r[B]&&r[B]&&(o+=1)}}return o}async function checkAllTokensConfigs(e,t){let n={};for(let[a,o]of Object.entries(t)){let r=o.blockchain,l=o.contractAddress,s=o.contractAddressName,u=o.tokenIDs,c=0==Number(o.minNumToken)?1:Number(o.minNumToken),p=!1,y=0,f=u?.split(",");if(f?.length>0&&("solana"==r.toLowerCase()||"ethereum"==r.toLowerCase()||"polygon"==r.toLowerCase()||"algorand"==r.toLowerCase())){let d=!0,m=0,g=null;for(;!0==d&&(y+=await mapAssetDataAndConfigAndGetBalance(g=await getUserAccountAssetsDetails(e,l,r,f,g?.pageKey),l,f,r),d=!!g?.pageKey,totalNumPages=g?.totalCount/100+1,!(++m>totalNumPages)););console.log("totalTokenBalance",y,"contractAddressName",s)}else y="loopring"==r.toLowerCase()?await getBalanceFromLoopring(e,l,u):await getBalanceOfMultipleTokens(e,l,r,u);p=y>=c,n[s]={balance:y,minNumToken:c,hasContentAccess:p}}return n}async function checkRoleMapping(e,t,n,a){for(i=1,mapping_count=void 0!==t.role_mapping_count?parseInt(t.role_mapping_count):0,contracts=[];i<=mapping_count;i++)for(j in mappedContractAddressNameArr=(mappedContractAddressName=void 0!==t["_mapping_key_"+i]?t["_mapping_key_"+i]:"").split(",")){let o=mappedContractAddressNameArr[j];if(n[o]){let r=n[o].minNumToken,l;a[o].balance>=(r=Number(r))&&contracts.push(o)}}return contracts}